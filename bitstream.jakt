import util { min }
class BitStream {
    private bit_offset: u8 = 0
    private byte_offset: usize = 0
    private bytes: [u8]

    public fn init(anon bytes: [u8]) throws -> BitStream => BitStream(bytes)

    public fn read(mut this, bits: u16) -> u64 {
        guard bits <= 12 else {
            eprintln("The maximum allowed number of bits is 12 and you are trying to read {}.", bits)
            abort()
        }

        mut temp = 0u64
        for i in 0..bits {
            guard .byte_offset < .bytes.size() else {
                eprintln("Cannot read more bits than are in the stream!")
                eprintln(
                    "Trying to read {} bits. byte offset: {}, bit offset: {}, bytes size: {}"
                    bits
                    .byte_offset
                    .bit_offset
                    .bytes.size()
                )
                abort()
            }
            let byte = .bytes[.byte_offset]
            let mask = 0b1 << .bit_offset
            let bit = (byte & mask) as! u64

            if bit > 0 {
                temp += (0b1 << i) as! u64
            }

            .bit_offset++
            if .bit_offset >= 8 {
                .bit_offset = 0
                .byte_offset++
            }
        }

        return temp
    }

    public fn read2(mut this, bits: u16) -> u64 {
        mut result = 0u64
        mut rbits = 0u16
        while (rbits < bits) {
            guard .byte_offset < .bytes.size() else {
                abort()
            }
            let bbits = min(8 - .bit_offset, bits - rbits)
            let mask = (0xFF >> (8 - bbits)) << .bit_offset
            result += (((.bytes[.byte_offset]&mask) >> .bit_offset) << rbits) as! u64
            rbits += bbits
            .bit_offset += bbits
            if (.bit_offset == 8) {
                .byte_offset += 1
                // this.totalByteOffset += 1;
                .bit_offset = 0
            }
        }
        return result
    }
}