import bitstream { BitStream }
import util { array_copy, combine_two_bytes, flatten, join, map, pow, print_in_rows, sort }

struct Color {
    r: u8
    g: u8
    b: u8
}

class GIFDecoder {
    current: usize
    bytes: [u8]

    public fn init(anon bytes: [u8]) throws -> GIFDecoder => GIFDecoder(current: 0, bytes)

    public fn decode(mut this) throws {
        // 1. GIF Signature
        let signature = .gif_signature()
        guard signature == "GIF89a" or signature == "GIF87a" else {
            eprintln("Not a gif file. expected gif signature, got {}", signature)
            abort()
        }

        // 2. Screen Descriptor
        let screen_descriptor = .screen_descriptor()

        // 3. Global Color Map
        let global_color_map: [Color]? = match screen_descriptor.global_color_map_follows_descriptor {
            true => .color_map(size: pow(base: 2u64, exponent: screen_descriptor.bits_per_pixel_in_image as! u64 + 1))
            false => None
        }

        // FIXME: Application Extension
        // FIXME: Comment Extension
        // FIXME: Graphics Control Extension
        // FIXME: Plain Text Extension

        // 4. Image Descriptor
        let image_descriptor = .image_descriptor()

        // 5. Local Color Map
        let local_color_map: [Color]? = match image_descriptor.use_local_color_map {
            true => .color_map(size: pow(base: 2u64, exponent: image_descriptor.bits_per_pixel! as! u64 + 1))
            false => None
        }
        // 6. Raster Data
        let raster_data = .raster_data()

        // 7. GIF Terminator
        .gif_terminator()

        let code_stream = raster_data.to_code_stream()
        mut code_table = CodeTable::init(color_map: local_color_map ?? global_color_map!)
        let index_stream = code_stream.decode(code_table: &mut code_table)
        let cm = global_color_map!
        let colors = map(index_stream.indices, fn[&cm](t: u64) throws -> Color => cm[t])
        let strs = map(
            colors
            fn(t: Color) throws -> String => format(
                "\033[48;2;{};{};{}m \033[0m",
                t.r,
                t.g,
                t.b
            )
        )
        print_in_rows(strs, row_length: image_descriptor.image_width as! u64)
    }

    fn gif_signature(mut this) throws -> String {
        mut builder = StringBuilder::create()
        for i in 0..6 {
            builder.append(.bytes[i])
        }
        .current = 6
        return builder.to_string()
    }

    fn screen_descriptor(mut this) -> ScreenDescriptor {
        let screen_width = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])
        let screen_height = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])
        let byte_5 = .bytes[.current++]
        let global_color_map_follows_descriptor = (byte_5 & 0b10000000) != 0
        let bits_of_color_resolution = (byte_5 & 0b01110000) >> 4
        let bits_per_pixel_in_image = byte_5 & 0b00000111
        let background = .bytes[.current++]
        let byte_7 = .bytes[.current++]
        guard byte_7 == 0 else {
            eprintln("expected byte 7 of screen descriptor to be 0, got: {:b}", byte_7)
            abort()
        }

        return ScreenDescriptor(
            screen_width
            screen_height
            global_color_map_follows_descriptor
            bits_of_color_resolution
            bits_per_pixel_in_image
            background
        )
    }

    fn color_map(mut this, size: u64) throws -> [Color] {
        mut color_map: [Color] = []
        color_map.ensure_capacity(size as! usize)
        for _ in 0..(size) {
            color_map.push(Color(
                r: .bytes[.current++]
                g: .bytes[.current++]
                b: .bytes[.current++]
            ))
        }
        return color_map
    }

    fn image_descriptor(mut this) -> ImageDescriptor {
        while .bytes[.current] != b',' {
            .current++
        }
        let byte_1 = .bytes[.current++]
        guard byte_1 == b',' else {
            eprintln("Expected Image separator character `{}`, got: {}", b',', byte_1)
            abort()
        }

        let image_left = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])
        let image_top = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])
        let image_width = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])
        let image_height = combine_two_bytes(lsb: .bytes[.current++], msb: .bytes[.current++])

        let byte_10 = .bytes[.current++]
        let use_local_color_map = (byte_10 & 0b10000000) != 0
        let format_mode = match byte_10 & 0b01000000 {
            0 => ImageFormatMode::Sequential
            else => ImageFormatMode::Interlaced
        }
        let bits_per_pixel: u8? = match use_local_color_map {
            true => None
            false => byte_10 & 0b00000111
        }

        return ImageDescriptor(
            image_left
            image_top
            image_width
            image_height
            use_local_color_map
            format_mode
            bits_per_pixel
        )
    }

    fn raster_data(mut this) throws -> RasterData {
        let lzw_minimum_code_size = .bytes[.current++]
        mut rows: [[u8]] = []
        loop {
            let bytes_in_sub_block = .bytes[.current++]
            if bytes_in_sub_block == 0 { break }
            mut sub_block: [u8] = []
            sub_block.ensure_capacity(bytes_in_sub_block as! usize)
            for _ in 0..bytes_in_sub_block {
                sub_block.push(.bytes[.current++])
            }
            rows.push(sub_block)
        }
        return RasterData(
            lzw_minimum_code_size
            sub_blocks: rows
        )
    }

    fn gif_terminator(mut this) {
        let terminator = .bytes[.current++]
        guard terminator == b';' else {
            eprintln("expected terminator `{}`, got: {:x}", b';', terminator)
            abort()
        }
    }
}

struct ScreenDescriptor {
    screen_width: u16
    screen_height: u16
    global_color_map_follows_descriptor: bool
    bits_of_color_resolution: u8
    bits_per_pixel_in_image: u8
    background: u8
}

enum ImageFormatMode {
    Sequential
    Interlaced
}

struct ImageDescriptor {
    image_left: u16
    image_top: u16
    image_width: u16
    image_height: u16
    use_local_color_map: bool
    format_mode: ImageFormatMode
    bits_per_pixel: u8?
}

struct RasterData {
    lzw_minimum_code_size: u8
    sub_blocks: [[u8]]

    fn number_of_bits(this) -> u64 {
        return (.sub_blocks.size() * .sub_blocks[0].size() * 8) as! u64
    }

    fn to_code_stream(this) throws -> CodeStream {
        mut bitstream = BitStream::init(bytes: flatten(.sub_blocks))
        mut size = .lzw_minimum_code_size as! u16 + 1
        mut codestream: [u64] = []

        mut bits_read = 0u64
        mut i = 0u64
        while (bits_read + (size as! u64)) < .number_of_bits() {
            codestream.push(bitstream.read(bits: size))
            bits_read += size as! u64
            if ++i == pow(base: 2, exponent: (size - 1) as! u64) {
                size++
                i = 0
            }
        }

        guard .number_of_bits() - bits_read < 0b1111111111111111 else {
            eprintln(
                "too many bits left to read. expected less than {}, got {}"
                0b1111111111111111
                .number_of_bits() - bits_read
            )
            abort()
        }
        let leftovers = bitstream.read(bits: (.number_of_bits() - bits_read) as! u16)
        guard leftovers == 0 else {
            eprintln("expected leftovers to be 0, got {}", leftovers)
            abort()
        }

        return CodeStream(
            lzw_minimum_code_size: .lzw_minimum_code_size
            codes: codestream
        )
    }
}

struct CodeStream {
    lzw_minimum_code_size: u8
    codes: [u64]

    fn decode(this, code_table: &mut CodeTable) throws -> IndexStream {
        mut indices: [u64] = []

        let first_code_values = code_table.get(.codes[0])!
        guard first_code_values[0] is Clear else {
            eprintln("codes should start with the clear code")
            abort()
        }
        // let CODE be the first code in the code stream
        mut code = .codes[1]
        // output {CODE} to index stream
        indices.push(code)

        // set PREVCODE = CODE
        mut prevcode = code
        for i in 2...codes.size() {
            // let CODE be the next code in the code stream
            code = .codes[i]
            // is CODE in the code table?
            if code_table.get(code) is Some(value) {
                // Yes:
                // output {CODE} to index stream
                for val in value {
                    match val {
                        Color(index) => { indices.push(index) }
                        else => {}
                    }
                }
                // let K be the first index in {CODE}
                let k = value[0]
                // add {PREVCODE}+K to the code table
                mut new_value = array_copy(code_table.get(prevcode)!)
                new_value.push(k)
                code_table.add(new_value)
                // set PREVCODE = CODE
                prevcode = code
            } else {
                // No:
                // let K be the first index of {PREVCODE}
                mut new_value = array_copy(code_table.get(prevcode)!)
                let k = new_value[0]
                new_value.push(k)
                // output {PREVCODE}+K to index stream
                for val in new_value {
                    match val {
                        Color(index) => { indices.push(index) }
                        else => {}
                    }
                }
                // add {PREVCODE}+K to code table
                code_table.add(new_value)
                // set PREVCODE = CODE
                prevcode = code
            }
        }

        return IndexStream(indices)
    }
}

enum CodeTableValue {
    Color(u64)
    Clear
    EOI
}

struct CodeTable {
    private table: [u64:[CodeTableValue]]
    fn init(color_map: [Color]) throws -> CodeTable {
        mut code_table = CodeTable(table: [:])
        for i in 0..color_map.size() as! u64 {
            code_table.add([CodeTableValue::Color(i)])
        }
        code_table.add([CodeTableValue::Clear])
        code_table.add([CodeTableValue::EOI])
        return code_table
    }
    fn set(mut this, anon key: u64, anon val: [CodeTableValue]) throws {.table.set(key, val)}
    fn add(mut this, anon val: [CodeTableValue]) throws {.table.set(.table.keys().size() as! u64, val)}
    fn get(this, anon key: u64) -> [CodeTableValue]? => .table.get(key)
    fn has(this, anon key: u64) -> bool => .table.contains(key)

    fn to_string(this) throws -> String {
        mut builder = StringBuilder::create()
        builder.append("[\n")
        for key in sort(.table.keys()) {
            let value = .table.get(key)
            let s = match value.has_value() {
                true => code_table_value_array_to_string(value!)
                false => ""
            }
            builder.append(format("\t{}: {}\n", key, s))
        }
        builder.append("]")
        return builder.to_string()
    }
}

struct IndexStream {
    indices: [u64]
}

fn code_table_value_array_to_string(anon arr: [CodeTableValue]) throws -> String {
    return join(
        map(
            arr,
            fn(t: CodeTableValue) throws -> String => match t {
                Color(c) => format("{}", c)
                else => format("{}", t)
            }
        ),
        separator: ", "
    )
}

